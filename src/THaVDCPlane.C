//////////////////////////////////////////////////////////////////////////////
//                                                                           //
// THaVDCPlane                                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Here:                                                                     //
//        Units of measurements:                                             //
//        For cluster position (center) and size  -  wires;                  //
//        For X, Y, and Z coordinates of track    -  meters;                 //
//        For Theta and Phi angles of track       -  in tangents.            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "THaVDC.h"
#include "THaVDCPlane.h"
#include "THaVDCWire.h"
#include "THaVDCUVPlane.h"
#include "THaVDCCluster.h"
#include "THaVDCHit.h"
#include "THaDetMap.h"
#include "THaVDCAnalyticTTDConv.h"
#include "TString.h"
#include "TClass.h"
#include "TMath.h"
#include "VarDef.h"
#include "TBRIK.h"
#include "TRotMatrix.h"
#include "THaString.h"
#include "TGraph.h"

#include <cstring>
#include <vector>
#include <iostream>

using namespace std;

// Forward dec for helper function to multiply matrices.
void MatrixMultiply(TRotMatrix* mdest, TRotMatrix* m1, TRotMatrix* m2); 

//_____________________________________________________________________________
THaVDCPlane::THaVDCPlane( const char* name, const char* description,
			  THaDetectorBase* parent )
  : THaSubDetector(name,description,parent), fTable(NULL), fTTDConv(NULL),
    fVDC(NULL)
{
  // Constructor

  // Since TCloneArrays can resize, the size here is fairly unimportant
  fHits     = new TClonesArray("THaVDCHit", 20 );
  fClusters = new TClonesArray("THaVDCCluster", 5 );
  fWires    = new TClonesArray("THaVDCWire", 368 );

  if( fDetector )
    fVDC = static_cast<THaSubDetector*>(fDetector)->GetDetector();
}

//_____________________________________________________________________________
void THaVDCPlane::MakePrefix()
{
  // Special treatment of the prefix for VDC planes: We don't want variable
  // names such as "R.vdc.uv1.u.x", but rather "R.vdc.u1.x".

  TString basename;
  THaDetectorBase* parent = NULL;
  if( fDetector && fDetector->IsA()->InheritsFrom("THaSubDetector") )
    parent = static_cast<THaSubDetector*>(fDetector)->GetDetector();
  if( parent )
    basename = parent->GetPrefix();
  if( fName.Contains("u") )
    basename.Append("u");
  else if ( fName.Contains("v") )
    basename.Append("v");
  if( fDetector && strstr( fDetector->GetName(), "uv1" ))
    basename.Append("1.");
  else if( fDetector && strstr( fDetector->GetName(), "uv2" ))
    basename.Append("2.");
  if( basename.Length() == 0 )
    basename = fName + ".";

  delete [] fPrefix;
  fPrefix = new char[ basename.Length()+1 ];
  strcpy( fPrefix, basename.Data() );
}

//_____________________________________________________________________________
Int_t THaVDCPlane::ReadDatabase( const TDatime& date )
{
  // Allocate TClonesArray objects and load plane parameters from database

  FILE* file = OpenFile( date );
  if( !file ) return kFileError;

  // Use default values until ready to read from database
  
  static const char* const here = "ReadDatabase()";
  const int LEN = 100;
  char buff[LEN];
  
  // Build the search tag and find it in the file. Search tags
  // are of form [ <prefix> ], e.g. [ R.vdc.u1 ].
  TString tag(fPrefix);
  tag.Replace( tag.Length()-1, 1, "" );  // delete trailing dot of prefix
  if( SeekDBconfig(file,tag,"") == 0 ) {
    Error(Here(here), "Database entry \"%s\" not found!", tag.Data() );
    fclose(file);
    return kInitError;
  }

  //Found the entry for this plane, so read data
  Int_t nWires = 0;    // Number of wires to create
  Int_t crate, slot, lo, hi;
  // Set up the detector map
  fDetMap->Clear();
  for (int i = 0; i < 4; i++) {
    // Get crate, slot, low channel and high channel from file
    fscanf(file, "%d%d%d%d", &crate, &slot, &lo, &hi);
    // Add module to the detector map
    fDetMap->AddModule(crate, slot, lo, hi);
    nWires += (hi - lo + 1); //More wires
    fgets(buff, LEN, file);  //Read to end of line
  }
  // Load z, wire beginning postion, wire spacing, and wire angle
  const Double_t degrad = TMath::Pi()/180.0;
  float z, wbeg, wspac, wangle;
  fscanf (file, "%f%f%f%f", &z, &wbeg, &wspac, &wangle);
  fgets(buff, LEN, file);  //Read to end of line
  fZ = z;
  fWBeg = wbeg;     
  fWSpac = wspac;
  fWAngle = wangle * degrad; // Convert to radians
  // FIXME: Read from file
  fTDCRes = 5.0e-10;  // 0.5 ns/chan = 5e-10 s /chan

  // Load drift velocity (will be used to initialize Crude Time to Distance
  // converter)
  float driftVel;
  fscanf(file, "%f", &driftVel);
  fgets(buff, LEN, file); // Read to end of line
  fgets(buff, LEN, file); // Skip line

  fDriftVel = driftVel;

  fNWiresHit = 0;
  
  // Values are the same for each plane
  fNMaxGap = 1;
  fMinTime = 800;
  fMaxTime = 2200;

  // first read in the time offsets for the wires
  float* wire_offsets = new float[nWires];

  for (int i = 0; i < nWires; i++) {
    float offset = 0.0;
    fscanf(file, " %*d %f", &offset);
    wire_offsets[i] = offset;
  }

  // now read in the time-to-drift-distance lookup table
  // data (if it exists)
  fgets(buff, LEN, file); // read to the end of line
  fgets(buff, LEN, file);
  if(strncmp(buff, "TTD Lookup Table", 16) == 0) {
    // if it exists, read the data in
    fscanf(file, "%le", &fT0);
    fscanf(file, "%d", &fNumBins);
    
    // this object is responsible for the memory management 
    // of the lookup table
    delete [] fTable;
    fTable = new Float_t[fNumBins];
    for(int i=0; i<fNumBins; i++) {
      fscanf(file, "%e", &(fTable[i]));
    }
  } else {
    // if not, set some reasonable defaults and rewind the file
    fT0 = 0.0;
    fNumBins = 0;
    fTable = NULL;
    cout<<"Could not find lookup table header: "<<buff<<endl;
    fseek(file, -strlen(buff), SEEK_CUR);
  }

  // Define time-to-drift-distance converter
  // Currently, we use the analytic converter. 
  // FIXME: Let user choose this via a parameter
  delete fTTDConv;
  fTTDConv = new THaVDCAnalyticTTDConv(driftVel);

  //THaVDCLookupTTDConv* ttdConv = new THaVDCLookupTTDConv(fT0, fNumBins, fTable);

  // Now initialize wires (those wires... too lazy to initialize themselves!)
  // Caution: This may not correspond at all to actual wire channels!
  for (int i = 0; i < nWires; i++)
    new((*fWires)[i]) THaVDCWire( i, fWBeg+i*fWSpac, wire_offsets[i], 
				  fTTDConv );

  delete [] wire_offsets;
  /*
  for (int i = 0; i < nWires; i++) {

    float offset = 0.0;
    fscanf(file, " %*d %f", &offset);

    // Construct the new THaVDCWire (using space in the TClonesArray obj)
    new((*fWires)[i]) THaVDCWire( i, fWBeg+i*fWSpac, offset, ttdConv );
  }
  */

  fOrigin.SetXYZ( 0.0, 0.0, fZ );
  if( fDetector )
    fOrigin += fDetector->GetOrigin();

  fIsInit = true;
  fclose(file);
  return kOK;
}

//_____________________________________________________________________________
Int_t THaVDCPlane::DefineVariables( EMode mode )
{
  // initialize global variables

  if( fIsSetup ) return kOK;
  fIsSetup = ( mode == kDefine );

  // Register variables in global list

  RVarDef vars[] = {
    { "nhit",   "Number of hits",             "GetNHits()" },
    { "wire",   "Active wire numbers",        "fHits.THaVDCHit.GetWireNum()" },
    { "rawtime","Raw TDC values of wires",    "fHits.THaVDCHit.fRawTime" },
    { "time",   "TDC values of active wires", "fHits.THaVDCHit.fTime" },
    { "dist",   "Drift distances",            "fHits.THaVDCHit.fDist" },
    { "nclust", "Number of clusters",         "GetNClusters()" },
    { "clsiz",  "Cluster sizes",              "fClusters.THaVDCCluster.fSize" },
    { "clpivot","Cluster pivot wire num",     "fClusters.THaVDCCluster.GetPivotWireNum()" },
    { "clpos",  "Cluster intercepts",         "fClusters.THaVDCCluster.fInt" },
    { "slope",  "Cluster slopes",             "fClusters.THaVDCCluster.fSlope" },
    { "sigsl",  "Cluster slope sigmas",       "fClusters.THaVDCCluster.fSigmaSlope" },
    { "sigpos", "Cluster position sigmas",    "fClusters.THaVDCCluster.fSigmaInt" },
    { 0 }
  };
  return DefineVarsFromList( vars, mode );

}

//_____________________________________________________________________________
THaVDCPlane::~THaVDCPlane()
{
  // Destructor.

  if( fIsSetup )
    RemoveVariables();
  delete fWires;
  delete fHits;
  delete fClusters;
  delete fTTDConv;
  delete [] fTable;
}

//_____________________________________________________________________________
inline
void THaVDCPlane::Clear( Option_t* opt )
{    
  // Clears the contents of the and hits and clusters
  fNWiresHit = 0;
  fHits->Clear();
  fClusters->Clear();
}

//_____________________________________________________________________________
Int_t THaVDCPlane::Decode( const THaEvData& evData)
{    
  // Converts the raw data into hit information
  // Assumes channels & wires  are numbered in order
  // TODO: Make sure the wires are numbered in order, even if the channels
  //       aren't
              

  Clear();  //Clear the last event

  if (!evData.IsPhysicsTrigger()) return -1;
  
  Int_t nextHit = 0;
  Int_t wireOffset = 0;

  bool only_fastest_hit, no_negative;
  if( fVDC ) {
    // If true, add only the first (earliest) hit for each wire
    only_fastest_hit = fVDC->TestBit(THaVDC::kOnlyFastest);
    // If true, ignore negativ drift times completely
    no_negative      = fVDC->TestBit(THaVDC::kIgnoreNegDrift);
  } else
    only_fastest_hit = no_negative = false;

  // Loop over all detector modules for this wire plane
  for (Int_t i = 0; i < fDetMap->GetSize(); i++) {
    THaDetMap::Module * d = fDetMap->GetModule(i);
    
    // Get number of channels with hits
    Int_t nChan = evData.GetNumChan(d->crate, d->slot);
    for (Int_t chNdx = 0; chNdx < nChan; chNdx++) {
      // Use channel index to loop through channels that have hits

      Int_t chan = evData.GetNextChan(d->crate, d->slot, chNdx);
      if (chan < d->lo || chan > d->hi) 
	continue; //Not part of this detector

      // Wire numbers and channels go in the same order ... 
      Int_t wireNum    = wireOffset + chan;
      THaVDCWire* wire = GetWire(wireNum);
      if( !wire ) continue;  // oops: junk from decoder?

      // Get number of hits for this channel and loop through hits
      Int_t nHits = evData.GetNumHits(d->crate, d->slot, chan);
   
      Int_t max_data = -1;
      for (Int_t hit = 0; hit < nHits; hit++) {
	
	// Now get the TDC data for this hit
	Int_t data = evData.GetData(d->crate, d->slot, chan, hit);
	if( only_fastest_hit ) {
	  if( data > max_data )
	    max_data = data;
	} else {
	  Double_t time = fTDCRes * (wire->GetTOffset() - data);
	  if( !no_negative || time > 0.0 )
	    new( (*fHits)[nextHit++] )  THaVDCHit( wire, data, time );
	}
	  
      } // End hit loop

      if( only_fastest_hit ) {
	Double_t time = fTDCRes * (wire->GetTOffset() - max_data);
	// FIXME: This is tricky ... could be that the next slower hit was good
	if( !no_negative || time > 0.0 )
	  new( (*fHits)[nextHit++] ) 
	    THaVDCHit( wire, max_data, time );
      }
    } // End channel index loop
    wireOffset += (d->hi - d->lo + 1);
  } // End slot loop

  // Sort the hits in order of increasing wire number and (for the same wire
  // number) increasing time (NOT rawtime)

  fHits->Sort();

  return 0;

}


//_____________________________________________________________________________
Int_t THaVDCPlane::FindClusters()
{
  // Reconstruct clusters in a VDC plane
  // Assumes that the wires are numbered such that increasing wire numbers
  // correspond to decreasing physical position.
  // Ignores possibility of overlapping clusters

  //FIXME: Requires ROOT 3.02. Below is a non-equivalent workaround.
  //  bool hard_cut = fVDC->TestBits(THaVDC::kTDCbits) == kHardTDCcut;
  //  bool soft_cut = fVDC->TestBits(kTDCbits) == kSoftTDCcut;
  bool hard_cut, soft_cut;
  if( fVDC ) {
    hard_cut = fVDC->TestBit(THaVDC::kHardTDCcut);
    soft_cut = fVDC->TestBit(THaVDC::kSoftTDCcut);
  } else
    hard_cut = soft_cut = false;
  Double_t maxdist = 0.0;
  if( soft_cut ) {
    maxdist = static_cast<THaVDCUVPlane*>(fDetector)->GetSpacing() / 2.0;
    if( maxdist == 0.0 )
      soft_cut = false;
  }

  Int_t pwireNum = -10;         // Previous wire number
  Int_t wireNum  =   0;         // Current wire number
  Int_t ndif     =   0;         // Difference between wire numbers
  Int_t nHits    = GetNHits();  // Number of hits in the plane
  THaVDCCluster* clust = NULL;  // Current cluster
  THaVDCHit* hit;               // current hit

//    Int_t minTime = 0;        // Smallest TDC time for a given cluster
//    THaVDCHit * minHit = NULL; // Hit with the smallest TDC time for 
                             // a given cluster
  //  const Double_t sqrt2 = 0.707106781186547462;

  Int_t nextClust = GetNClusters();  // Should be zero

  for ( int i = 0; i < nHits; i++ ) {
    //Loop through all TDC  hits
    if( !(hit = GetHit(i)))
      continue;

    // Time within sanity cuts?
    if( hard_cut ) {
      Int_t rawtime = hit->GetRawTime();
      if( rawtime < fMinTime || rawtime > fMaxTime) 
	continue;
    }
    if( soft_cut ) {
      Double_t ratio = hit->GetTime() * fDriftVel / maxdist;
      if( ratio < -0.5 || ratio > 1.5 )
	continue;
    }

    wireNum = hit->GetWire()->GetNum();  

    // Ignore multiple hits per wire
    if ( wireNum == pwireNum )
      continue;

    // Keep track of how many wire were hit
    fNWiresHit++;
    ndif = wireNum - pwireNum;
    if (ndif < 0) {
      // Scream Bloody Murder
      printf("THaVDCPlane::FindCluster()-Wire Ordering Error\n");
      return 0;
    }

    pwireNum = wireNum;
    if ( ndif > fNMaxGap+1 ) {
      // Found a new cluster
      if (clust) 
	// Estimate the track parameters for this cluster
	// (Pivot, intercept, and slope)
	clust->EstTrackParameters();

      // Make a new THaVDCCluster (using space from fCluster array)  
      clust = new ( (*fClusters)[nextClust++] ) THaVDCCluster(this);
    } 
    //Add hit to the cluster
    clust->AddHit(hit);

  } // End looping through hits

  // Estimate track parameters for the last cluster found
  if (clust)
    clust->EstTrackParameters(); 

  return GetNClusters();  // return the number of clusters found
}

//_____________________________________________________________________________
Int_t THaVDCPlane::FitTracks()
{    
  // Fit tracks to cluster positions and drift distances.
  
  THaVDCCluster* clust;
  Int_t nClust = GetNClusters();
  for (int i = 0; i < nClust; i++) {
    if( !(clust = static_cast<THaVDCCluster*>( (*fClusters)[i] )))
      continue;

    // Convert drift times to distances. 
    // The conversion algorithm is determined at wire initialization time,
    // i.e. currently in the ReadDatabase() function of this class.
    // Current best estimates of the track parameters will be passed to
    // the converter.
    clust->ConvertTimeToDist();

    // Fit drift distances to get intercept, slope.
    clust->FitTrack();
  }
  return 0;
}
//_____________________________________________________________________________
void THaVDCPlane::Draw(TGeometry* geom,const THaEvData& evdata, const Option_t* opt)
{
  // Draw wire plane

  Clear();
  Decode(evdata);

  THaVDC* VDC = static_cast<THaVDC*>( fVDC);

  THaString rot;

  /*

  THaString temp;
  if( opt != NULL)
    temp = opt;
  
  vector<THaString> s;

  s = temp.Split();

  for(Int_t i = 0; i < s.size(); i++)
    {
      if(s[i].find("rot=") == 0)
	 rot = s[i].substr(4);
    }
  
  */

  if( fWAngle == TMath::Pi()/4)
    rot = "XY45";
  else
    rot = "XY-45";


  TIter next( fHits->MakeIterator());

  //  TIter next( fWires->MakeIterator());

  Double_t len = VDC->fSize[1]/TMath::Sin(fWAngle*180/TMath::Pi());

  if(!geom->GetShape("VDCWIRE"))
    {
      TBRIK* b = new TBRIK("VDCWIRE","VDCWIRE","void",0,len,0);

      //Save pointer to delete later.

    }

  TRotMatrix* xz = geom->GetRotMatrix("XZ");
      //Fix: this is dangerous because we cannot be sure of the existence
      // of the XZ Matrix.

  if(!geom->GetRotMatrix("XY45"))
    {

      TRotMatrix* xyvdc =  new TRotMatrix("XY45","XY45",90,45,90,135,0,0);

      MatrixMultiply(xyvdc,xyvdc,xz);

      (geom->GetListOfMatrices())->Add(xyvdc);
    }

  if(!geom->GetRotMatrix("XY-45"))
    {

      TRotMatrix* yxvdc =  new TRotMatrix("XY-45","XY-45",90,-45,90,45,0,0);

      MatrixMultiply(yxvdc,yxvdc,xz);

      (geom->GetListOfMatrices())->Add(yxvdc);

    }


  THaVDCWire* wire;
  THaVDCHit* hit;
  while(hit = static_cast<THaVDCHit*>( next() ) )
    {
      wire = hit->GetWire();
      cout << "pos: " << wire->GetPos() << endl;

      //Conversion to plane coords.
      Double_t uv = wire->GetPos() - fZ*TMath::Cos(VDC->GetVDCAngle());

      //Conversion to Transport coords.
      Double_t x = uv/TMath::Cos(fWAngle);

      TString wireid = "HITWIRE";
      wireid += wire->GetNum();

      cout << "Wireid: " << wireid << endl;

      geom->Node(wireid,"WIRE","VDCWIRE",
		 x*TMath::Cos(VDC->GetVDCAngle()),
		 0,
		 fZ+x*TMath::Sin(VDC->GetVDCAngle()),
		 rot.c_str());
      
    }

}

//_____________________________________________________________________________
void THaVDCPlane::DrawHitGraph( const Option_t* opt)
{

  TIter next(fHits);

  Int_t nhits = fHits->GetEntries();

  THaVDCHit* hit;


  Double_t x[nhits],y[nhits];
  Int_t i = 0;

  while(hit = static_cast<THaVDCHit*>( next() ) )
    {
     x[i] = hit->GetWire()->GetNum();
     y[i] = hit->GetTime();
      
    }
  
  //Fix: Free this!
  TGraph* g = new TGraph(nhits,x,y);
  g->SetTitle(fName);
  g->Draw(opt);

}


//_____________________________________________________________________________

void MatrixMultiply(TRotMatrix* mdest,TRotMatrix* m1, TRotMatrix* m2)
{

  Double_t temp[9];
  Double_t* e1 = m1->GetMatrix();
  Double_t* e2 = m2->GetMatrix();
  
  temp[0] = (e1[0] * e2[0]) + (e1[1] * e2[3]) + (e1[2] * e2[6]);
  temp[1] = (e1[0] * e2[1]) + (e1[1] * e2[4]) + (e1[2] * e2[7]);
  temp[2] = (e1[0] * e2[2]) + (e1[1] * e2[5]) + (e1[2] * e2[8]);

  temp[3] = (e1[3] * e2[0]) + (e1[4] * e2[3]) + (e1[5] * e2[6]);
  temp[4] = (e1[3] * e2[1]) + (e1[4] * e2[4]) + (e1[5] * e2[7]);
  temp[5] = (e1[3] * e2[2]) + (e1[4] * e2[5]) + (e1[5] * e2[8]);

  temp[6] = (e1[6] * e2[0]) + (e1[7] * e2[3]) + (e1[8] * e2[6]);
  temp[7] = (e1[6] * e2[1]) + (e1[7] * e2[4]) + (e1[8] * e2[7]);
  temp[8] = (e1[6] * e2[2]) + (e1[7] * e2[5]) + (e1[8] * e2[8]);

  mdest->SetMatrix(temp);
} 

///////////////////////////////////////////////////////////////////////////////
ClassImp(THaVDCPlane)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// THaVDCCluster                                                             //
//                                                                           //
// A group of VDC hits and routines for linear and non-linear fitting of     //
// drift distances.                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "THaVDCCluster.h"
#include "THaVDCHit.h"
#include "THaVDCPlane.h"
#include "THaVDCUVTrack.h"
#include "THaTrack.h"
#include "TMath.h"
#include "TClass.h"

// ROOT matrix magic for non-linear fit routine
#include "TMatrixD.h"
#include "TVectorD.h"
#include "TDecompQRH.h"
#include "TDecompSVD.h"
#include "TDecompBase.h"
 
#include <iostream>

using namespace std;

const Double_t THaVDCCluster::kBig = 1e38;  // Arbitrary large value

//_____________________________________________________________________________
THaVDCCluster::THaVDCCluster( const THaVDCCluster& rhs ) :
  TObject(rhs),
  fSize(rhs.fSize), fPlane(rhs.fPlane), fSlope(rhs.fSlope), 
  fLocalSlope(rhs.fLocalSlope), fSigmaSlope(rhs.fSigmaSlope),
  fInt(rhs.fInt), fSigmaInt(rhs.fSigmaInt), 
  fT0(rhs.fT0), fSigmaT0(rhs.fSigmaT0), fPivot(rhs.fPivot), 
  fIPivot(-1),
  fTimeCorrection(rhs.fTimeCorrection), fFitOK(rhs.fFitOK),
  fChi2(rhs.fChi2), fNDoF(rhs.fNDoF),
  fClsStr(-1), fClsEnd(-1), fPaired(rhs.fPaired), fAmbig(rhs.fAmbig)
{
  // Copy constructor

  for( int i = 0; i < fSize; i++ ) {
    fHits[i] = rhs.fHits[i];
  }
}

//_____________________________________________________________________________
THaVDCCluster& THaVDCCluster::operator=( const THaVDCCluster& rhs )
{
  // Assignment operator

  TObject::operator=( rhs );
  if( this != &rhs ) {
    fSize       = rhs.fSize;
    fPlane      = rhs.fPlane;
    fTrack      = rhs.fTrack;
    fSlope      = rhs.fSlope;
    fSigmaSlope = rhs.fSigmaSlope;
    fInt        = rhs.fInt;
    fSigmaInt   = rhs.fSigmaInt;
    fT0         = rhs.fT0;
    fSigmaT0    = rhs.fSigmaT0;
    fPivot      = rhs.fPivot;
    fIPivot     = rhs.fIPivot;
    fTimeCorrection = rhs.fTimeCorrection;
    fFitOK      = rhs.fFitOK;
    fLocalSlope = rhs.fLocalSlope;
    fChi2       = rhs.fChi2;
    fNDoF       = rhs.fNDoF;
    fPaired     = rhs.fPaired;
    fAmbig      = rhs.fAmbig;
    for( int i = 0; i < fSize; i++ )
      fHits[i] = rhs.fHits[i];
  }
  return *this;
}

//_____________________________________________________________________________
THaVDCCluster::~THaVDCCluster()
{
  // Destructor
}

//_____________________________________________________________________________
void THaVDCCluster::AddHit(THaVDCHit * hit)
{
  //Add a hit to the cluster

  if (fSize < MAX_SIZE) {
    fHits[fSize++] = hit;
    if( fSize == 1 ){
	    fClsStr = hit->GetWireNum();
	    fClsEnd = hit->GetWireNum();
    } else {
	    if( fClsEnd < hit->GetWireNum() ){
		    fClsEnd = hit->GetWireNum();
	    }
	    if( fClsStr > hit->GetWireNum() ){
		    fClsStr = hit->GetWireNum();
	    }
    }
    
  } else if( fPlane && fPlane->GetDebug()>0 ) {
    Warning( "AddHit()", "Max cluster size reached.");
  }
}

//_____________________________________________________________________________
void THaVDCCluster::Clear( const Option_t* )
{
  // Clear the contents of the cluster

  ClearFit();
  fSize   = 0;
  fPivot  = 0;
  fPlane  = 0;
//    fUVTrack = NULL;
  fTrack = 0;

}

//_____________________________________________________________________________
void THaVDCCluster::ClearFit()
{
  // Clear fit results only
  
  fSlope      = kBig;
  fSigmaSlope = kBig;
  fInt        = kBig;
  fSigmaInt   = kBig;
  fT0         = 0.0;
  fSigmaT0    = kBig;
  fIPivot     = -1;
  fFitOK      = false;
  fLocalSlope = kBig;
  fChi2       = kBig;
  fNDoF       = 0.0;
  fPaired     = 0;
  fAmbig      = kFALSE;
}

//_____________________________________________________________________________
Int_t THaVDCCluster::Compare( const TObject* obj ) const
{
  // Compare this cluster to another via the wire number of the pivot.
  // Returns -1 if comparison cannot be made (unlike class, no pivot).

  if( !obj || IsA() != obj->IsA() )
    return -1;

  const THaVDCCluster* rhs = static_cast<const THaVDCCluster*>( obj );
  if( GetPivotWireNum() < rhs->GetPivotWireNum() )
    return -1;
  if( GetPivotWireNum() > rhs->GetPivotWireNum() )
    return +1;

  return 0;
}

//_____________________________________________________________________________
void THaVDCCluster::EstTrackParameters()
{
  // Estimate Track Parameters
  // Calculates pivot wire and uses its position as position of cluster
  // Estimates the slope based on the distance between the first and last
  // wires to be hit in the U (or V) and detector Z directions

  fFitOK = false;
  if( fSize == 0 )
    return;
  
  // Find pivot
  Double_t time = 0, minTime = 1000;  // drift-times in seconds
  for (int i = 0; i < fSize; i++) {
    time = fHits[i]->GetTime();
    if (time < minTime) { // look for lowest time
      minTime = time;
      fPivot = fHits[i];
    }
  }
  
  // Now set intercept
  fInt = fPivot->GetPos();

  // Now find the approximate slope
  //   X = Drift Distance (m)
  //   Y = Position of Wires (m)
  if( fSize > 1 ) {
    Double_t conv = fPlane->GetDriftVel();  // m/s
    Double_t dx = conv * (fHits[0]->GetTime() + fHits[fSize-1]->GetTime());
    Double_t dy = fHits[0]->GetPos() - fHits[fSize-1]->GetPos();
    fSlope = dy / dx;
  } else
    fSlope = 1.0;

  fFitOK = true;
}

//_____________________________________________________________________________
void THaVDCCluster::ConvertTimeToDist()
{
  // Convert TDC Times in wires to drift distances

  //Do conversion for each hit in cluster
  for (int i = 0; i < fSize; i++)
    fHits[i]->ConvertTimeToDist(fSlope);
}

//_____________________________________________________________________________
chi2_t THaVDCCluster::CalcDist()
{
  // Calculate and store the distance of the global track to the wires.
  // We can then inspect the quality of the fits.
  //
  // This is actually a bit tedious: we need to project the track
  // (given by its detector coordinates) onto this cluster's plane (u or v),
  // then find the track's z coordinate for each active wire's position.
  // It takes two pages of vector algebra.
  //
  // Return value: sum of squares of distances and number of hits used

  assert( fTrack );

  Int_t npt  = 0;
  Double_t chi2 = 0;
  for (int j = 0; j < fSize; j++) {
    // Use only hits marked to belong to this track
    if( fHits[j]->GetTrkNum() != fTrack->GetTrkNum() )
      continue;
    Double_t u     = fHits[j]->GetPos();    // u (v) coordinate of wire
    Double_t sina  = fPlane->GetSinAngle();
    Double_t cosa  = fPlane->GetCosAngle();
    Double_t denom = cosa*fTrack->GetDTheta() + sina*fTrack->GetDPhi();
    Double_t z     = (u - cosa*fTrack->GetDX() - sina*fTrack->GetDY()) / denom;
    Double_t dz    = z - fPlane->GetZ();
    fHits[j]->SetFitDist(TMath::Abs(dz));
    chi2 += dz*dz;
    npt++;
  }
  return make_pair( chi2, npt );
}
  
//_____________________________________________________________________________
void THaVDCCluster::CalcLocalDist()
{
  //FIXME: clean this up - duplicate of chi2 calculation
  // Calculate and store the distance of the local fitted track to the wires.
  // We can then inspect the quality of the local fits
  for (int j = 0; j < fSize; j++) {
    Double_t y = fHits[j]->GetPos();
    if (fLocalSlope != 0. && fLocalSlope < kBig) {
      Double_t X = (y-fInt)/fLocalSlope;
      fHits[j]->SetLocalFitDist(TMath::Abs(X));
    } else {
      fHits[j]->SetLocalFitDist(kBig);
    }
  }
}
  
//_____________________________________________________________________________
void THaVDCCluster::FitTrack( EMode /* mode */ )
{
  // Fit track to drift distances. Supports three modes:
  // 
  // kSimple:  Linear fit, ignore t0 and multihits
  // kT0:      Fit t0, but ignore mulithits
  // kFull:    Analyze multihits and fit t0
  // 
  // FIXME: kT0 and kFull are not yet implemented. Identical to kSimple.

//   FitSimpleTrack();
  //  FitSimpleTrackWgt();
  //LinearClusterFitWithT0();
  FitNLTrack();
  CalcLocalDist();
}

//_____________________________________________________________________________
void THaVDCCluster::FitSimpleTrack()
{
  // Perform linear fit on drift times. Calculates slope, intercept, and 
  // errors. Assume t0 = 0.

  // For this function,
  //   X = Drift Distance
  //   Y = Position of Wires

  fFitOK = false;
  if( fSize < 3 )
    return;  // Too few hits to get meaningful results
             // Do keep current values of slope and intercept

  Double_t N = fSize;  //Ensure that floating point calculations are used
  Double_t m, sigmaM;  // Slope, St. Dev. in slope
  Double_t b, sigmaB;  // Intercept, St. Dev in Intercept
  Double_t sigmaY;     // St Dev in delta Y values

  Double_t* xArr = new Double_t[fSize];
  Double_t* yArr = new Double_t[fSize];

  Double_t bestFit = 0.0;

  // Find the index of the pivot wire and copy distances into local arrays
  // Note that as the index of the hits is increasing, the position of the
  // wires is decreasing

  Int_t pivotNum = 0;
  for (int i = 0; i < fSize; i++) {
    if (fHits[i] == fPivot) {
      pivotNum = i;
    }
    xArr[i] = fHits[i]->GetDist() + fTimeCorrection;
    yArr[i] = fHits[i]->GetPos();
  }
  
  const Int_t nSignCombos = 2; //Number of different sign combinations
  for (int i = 0; i < nSignCombos; i++) {

    Double_t sumX  = 0.0;   //Drift distances
    Double_t sumXX = 0.0;
    Double_t sumY  = 0.0;   //Position of wires
    Double_t sumXY = 0.0;
    Double_t sumDY2 = 0.0;  // Sum of squares of delta Y values
    
    if (i == 0)
      for (int j = pivotNum+1; j < fSize; j++)
	xArr[j] = -xArr[j];
    else if (i == 1)
      xArr[pivotNum] = -xArr[pivotNum];

    for (int j = 0; j < fSize; j++) {
      Double_t x = xArr[j];  // Distance to wire
      Double_t y = yArr[j];   // Position of wire
      sumX  += x;
      sumXX += x * x;
      sumY  += y;
      sumXY += x * y;
    }

    // Standard formulae
    m  = (N * sumXY - sumX * sumY) / (N * sumXX - sumX * sumX);
    b  = (sumXX * sumY - sumX * sumXY) / (N * sumXX - sumX * sumX);

    // Calculate sum of delta y values
    for (int j = 0; j < fSize; j++) {
      Double_t y = yArr[j];
      Double_t Y = m * xArr[j] + b;
      sumDY2 += (y - Y) * (y - Y);
    } 
    
    sigmaY = TMath::Sqrt (sumDY2 / (N - 2));
    sigmaM = sigmaY * TMath::Sqrt ( N / ( N * sumXX - sumX * sumX) );
    sigmaB = sigmaY * TMath::Sqrt (sumXX / ( N * sumXX - sumX * sumX) );
    
    // Pick the best value
    if (i == 0 || sigmaY < bestFit) {
      bestFit = sigmaY;
      fLocalSlope = m;
      fSigmaSlope = sigmaM;
      fInt = b;
      fSigmaInt = sigmaB;
    }
  }

  // calculate the best possible chi2 for the track given this slope and intercept
  Double_t chi2 = 0.;
  Int_t nhits = 0;
  
  CalcChisquare(chi2,nhits);
  fChi2 = chi2;
  fNDoF = nhits-2;
  
  fFitOK = true;

  delete[] xArr;
  delete[] yArr;
}

//_____________________________________________________________________________
void THaVDCCluster::FitSimpleTrackWgt()
{
  // Perform linear fit on drift times. Calculates slope, intercept, and errors.
  // Does not assume the uncertainty is the same for all hits.
  //
  // Assume t0 = 0.

  // For this function, the final results is (m,b) in  Y = m X + b
  //   X = Drift Distance
  //   Y = Position of Wires


  fFitOK = false;
  if( fSize < 3 ) {
    return;  // Too few hits to get meaningful results
             // Do keep current values of slope and intercept
  }
  
  Double_t m, sigmaM;  // Slope, St. Dev. in slope
  Double_t b, sigmaB;  // Intercept, St. Dev in Intercept

  Double_t* xArr = new Double_t[fSize];
  Double_t* yArr = new Double_t[fSize];
  Double_t* wtArr= new Double_t[fSize];
  
  Double_t bestFit = 0.0;
  
  // Find the index of the pivot wire and copy distances into local arrays
  // Note that as the index of the hits is increasing, the position of the
  // wires is decreasing

  Int_t pivotNum = 0;
  for (int i = 0; i < fSize; i++) {

    // In order to take into account the varying uncertainty in the
    // drift distance, we will be working with the X' and Y', and
    //       Y' = F + G X'
    //  where Y' = X, and X' = Y  (swapping it around)
    if (fHits[i] == fPivot) {
      pivotNum = i;
    }

    xArr[i] = fHits[i]->GetPos();
    yArr[i] = fHits[i]->GetDist() + fTimeCorrection;
    wtArr[i]= fHits[i]->GetdDist();

    // the hit will be ignored if the uncertainty is < 0
    if (wtArr[i]>0) wtArr[i] = 1./(wtArr[i]*wtArr[i]); // sigma^-2 is the weight
  }
  
  const Int_t nSignCombos = 2; //Number of different sign combinations
  for (int i = 0; i < nSignCombos; i++) {
    Double_t F, sigmaF2;  // intermediate slope and St. Dev.**2
    Double_t G, sigmaG2;  // intermediate intercept and St. Dev.**2
    Double_t sigmaFG;     // correlated uncertainty
    
    Double_t sumX  = 0.0;   //Positions
    Double_t sumXW = 0.0;
    Double_t sumXX = 0.0;
    Double_t sumY  = 0.0;   //Drift distances
    Double_t sumXY = 0.0;
    Double_t sumYY = 0.0;
    Double_t sumXXW= 0.0;
    
    Double_t W = 0.0;
    Double_t WW= 0.0;
    
    if (i == 0)
      for (int j = pivotNum+1; j < fSize; j++)
	yArr[j] *= -1;
    else if (i == 1)
      yArr[pivotNum] *= -1;

    for (int j = 0; j < fSize; j++) {
      Double_t x = xArr[j];   // Position of wire
      Double_t y = yArr[j];   // Distance to wire
      Double_t w =wtArr[j];
      
      if (w <= 0) continue;
      W     += w;
      WW    += w*w;
      sumX  += x * w;
      sumXW += x * w * w;
      sumXX += x * x * w;
      sumXXW+= x * x * w * w;
      sumY  += y * w;
      sumXY += x * y * w;
      sumYY += y * y * w;
    }

    // Standard formulae for linear regression (see Bevington)
    Double_t Delta = W * sumXX - sumX * sumX;

    F  = (sumXX * sumY - sumX * sumXY) / Delta;
    G  = (W * sumXY - sumX * sumY) / Delta;
    sigmaF2 = ( sumXX / Delta );
    sigmaG2 = ( W / Delta );
    sigmaFG = ( sumXW * W * sumXX - sumXXW * W * sumX
		- WW * sumX * sumXX + sumXW * sumX * sumX ) / (Delta*Delta);

    m  =   1/G;
    b  = - F/G;

    sigmaM = m * m * TMath::Sqrt( sigmaG2 );
    sigmaB = TMath::Sqrt( sigmaF2/(G*G) + F*F/(G*G*G*G)*sigmaG2 - 2*F/(G*G*G)*sigmaFG);
    
    // calculate the best possible chi2 for the track given this slope and intercept
    Double_t chi2 = 0.;
    Int_t nhits = 0;
    
    CalcChisquare(chi2,nhits);
    
    // scale the uncertainty of the fit parameters based upon the
    // quality of the fit. This really should not be necessary if
    // we believe the drift-distance uncertainties
    sigmaM *= chi2/(nhits - 2);
    sigmaB *= chi2/(nhits - 2);
    
    // Pick the best value
    if (i == 0 || chi2 < bestFit) {
      bestFit = chi2;
      fChi2 = chi2;
      fNDoF = nhits-2;
      fLocalSlope = m;
      fSigmaSlope = sigmaM;
      fInt = b;
      fSigmaInt = sigmaB;
    }
  }

  fFitOK = true;

  delete[] xArr;
  delete[] yArr;
  delete[] wtArr;
}

//_____________________________________________________________________________
Int_t THaVDCCluster::LinearClusterFitWithT0()
{
  // Perform linear fit on drift times. Calculates slope, intercept, time
  // offset t0, and errors.
  // Accounts for different uncertainties of each drift distance.
  //
  // Fits the parameters m, b, and d0 in
  //
  // s_i ( d_i + d0 ) = m x_i + b
  //
  // where
  //  s_i   = sign of ith drift distance (+/- 1)
  //  d_i   = ith measured drift distance
  //  x_i   = ith wire position
  //
  // The sign vector, s_i, is automatically optimized to yield the smallest
  // chi^2. Normally, s_i = -1 for i < i_pivot, and s_i = 1 for i >= i_pivot,
  // but this may occasionally not be the best choice in the presence of 
  // a significant negative offset d0.
  //
  // The results, m, b, and d0, are converted to the "slope" and "intercept"
  // of the cluster geometery, where slope = 1/m and intercept = -b/m.
  // d0 is simply converted to time units to give t0, using the asymptotic
  // drift velocity.


  fFitOK = false;
  if( fSize < 4 ) {
    return -1;  // Too few hits to get meaningful results
                // Do keep current values of slope and intercept
  }
  
  Double_t m, sigmaM;   // Slope, St. Dev. in slope
  Double_t b, sigmaB;   // Intercept, St. Dev in Intercept
  Double_t d0, sigmaD0;

  sigmaM = sigmaB = sigmaD0 = 0;

  Double_t* xArr = new Double_t[fSize];
  Double_t* dArr = new Double_t[fSize];
  Double_t* wArr = new Double_t[fSize];
  Int_t*    sArr = new Int_t[fSize];

  //--- Copy hit data into local arrays
  Int_t ihit, incr, ilast = fSize-1;
  // Ensure that the first element of the local arrays always corresponds 
  // to the wire with the smallest x position
  bool reversed = ( fPlane->GetWSpac() < 0 );
  if( reversed ) {
    ihit = ilast;
    incr = -1;
  } else {
    ihit = 0;
    incr = 1;
  }
  for( Int_t i = 0; i < fSize; ihit += incr, ++i ) {
    assert( ihit >= 0 && ihit < fSize );
    xArr[i] = fHits[ihit]->GetPos();
    dArr[i] = fHits[ihit]->GetDist() + fTimeCorrection;
    
    Double_t wt = fHits[ihit]->GetdDist();
    if( wt>0 )   // the hit will be ignored if the uncertainty is <= 0
      wArr[i] = 1./(wt*wt);
    else
      wArr[i] = -1.;

    assert( i == 0 || xArr[i-1] < xArr[i] );
  }

  Double_t bestFit = 0.0;

  //--- Perform 3-parameter for different sign coefficients
  //
  // We make some simplifying assumptions:
  // - The first wire of the cluster always has negative drift distance.
  // - The last wire always has positive drift.
  // - The sign flips exactly once from - to + somewhere in between
  sArr[0] = -1;
  for( Int_t i = 1; i < fSize; ++i )
    sArr[i] = 1;

  for( Int_t ipivot = 0; ipivot < ilast; ++ipivot ) {
    if( ipivot != 0 )
      sArr[ipivot] = -sArr[ipivot];;

    // Do the fit
    Linear3DFit( xArr, dArr, sArr, wArr, m, b, d0 );

    // calculate the best possible chi2 for the track given this slope, 
    // intercept, and distance offset
    chi2_t chi2 = CalcChisquare( xArr, dArr, sArr, wArr, m, b, d0 );
    
    // scale the uncertainty of the fit parameters based upon the
    // quality of the fit. This really should not be necessary if
    // we believe the drift-distance uncertainties
//     sigmaM *= chi2/(nhits - 2);
//     sigmaB *= chi2/(nhits - 2);
    
    // Pick the best value
    if( ipivot == 0 || chi2.first < bestFit ) {
      bestFit     = fChi2 = chi2.first;
      fNDoF       = chi2.second - 3;
      fLocalSlope = m;
      fInt        = b;
      fT0         = d0;
      fSigmaSlope = sigmaM;
      fSigmaInt   = sigmaB;
      fSigmaT0    = sigmaD0;
      fIPivot     = (reversed) ? ilast - ipivot : ipivot + 1;
    }
  }

  // Rotate the coordinate system to match the VDC definition of "slope"
  fLocalSlope = 1.0/fLocalSlope;  // 1/m
  fInt   = -fInt * fLocalSlope;   // -b/m
  if( fPlane )
    fT0  /= fPlane->GetDriftVel();
  
  fFitOK = true;

  delete[] wArr;
  delete[] sArr;
  delete[] dArr;
  delete[] xArr;

  return 0;
}

//_____________________________________________________________________________
void THaVDCCluster::Linear3DFit( const Double_t* xArr, const Double_t* dArr,
				 const Int_t* sArr, const Double_t* wArr,
				 Double_t& m, Double_t& b, Double_t& d0 ) const
{
  // 3-parameter fit 
//     Double_t F, sigmaF2;  // intermediate slope and St. Dev.**2
//     Double_t G, sigmaG2;  // intermediate intercept and St. Dev.**2
//     Double_t sigmaFG;     // correlated uncertainty
    
  Double_t sumX   = 0.0;   //Positions
  Double_t sumXX  = 0.0;
  Double_t sumD   = 0.0;   //Drift distances
  Double_t sumXD  = 0.0;
  Double_t sumS   = 0.0;   //sign vector
  Double_t sumSX  = 0.0;
  Double_t sumSD  = 0.0;
  Double_t sumSDX = 0.0;

  //     Double_t sumXW = 0.0;
  //     Double_t sumXXW= 0.0;
    
  Double_t sumW  = 0.0;
  //     Double_t sumWW = 0.0;
  //     Double_t sumDD = 0.0;
    

  for (int j = 0; j < fSize; j++) {
    Double_t x = xArr[j];   // Position of wire
    Double_t d = dArr[j];   // Distance to wire
    Double_t w = wArr[j];   // Weight/error of distance measurement
    Int_t    s = sArr[j];   // Sign of distance

    if (w <= 0) continue;

    sumX   += x * w;
    sumXX  += x * x * w;
    sumD   += d * w;
    sumXD  += x * d * w;
    sumS   += s * w;
    sumSX  += s * x * w;
    sumSD  += s * d * w;
    sumSDX += s * d * x * w;
    sumW   += w;
    //       sumWW  += w*w;
    //       sumXW  += x * w * w;
    //       sumXXW += x * x * w * w;
    //       sumDD  += d * d * w;
  }

  // Standard formulae for linear regression (see Bevington)
  Double_t Delta = 
    sumXX   * ( sumW  * sumW - sumW * sumS  ) -
    sumX    * ( sumX  * sumW - sumX * sumS  );

  m = 
    sumSDX  * ( sumW  * sumW - sumW * sumS  ) -
    sumSD   * ( sumX  * sumW - sumW * sumSX ) +
    sumD    * ( sumX  * sumS - sumW * sumSX );

  b =
    -sumSDX * ( sumX  * sumW - sumX * sumS  ) +
    sumSD   * ( sumXX * sumW - sumX * sumSX ) -
    sumD    * ( sumXX * sumS - sumX - sumSX );

  d0 = ( sumD - sumSD ) * ( sumXX * sumW - sumX * sumX );

  m  /= Delta;
  b  /= Delta;
  d0 /= Delta;


  //     F  = (sumXX * sumD - sumX * sumXD) / Delta;
  //     G  = (sumW * sumXD - sumX * sumD) / Delta;
  //     sigmaF2 = ( sumXX / Delta );
  //     sigmaG2 = ( sumW / Delta );
  //     sigmaFG = ( sumXW * sumW * sumXX - sumXXW * sumW * sumX
  // 		- sumWW * sumX * sumXX + sumXW * sumX * sumX ) / (Delta*Delta);

  //     m  =   1/G;
  //     b  = - F/G;

  //     sigmaM = m * m * TMath::Sqrt( sigmaG2 );
  //     sigmaB = TMath::Sqrt( sigmaF2/(G*G) + F*F/(G*G*G*G)*sigmaG2 - 2*F/(G*G*G)*sigmaFG);

}

//_____________________________________________________________________________
void THaVDCCluster::FitNLTrack()
{
  // Mike Paolone's non-linear 3-parameter fit

  // Perform a non-linear fit on drift times.  Calculates slope, intercept, 
  // t0, and errors.
  // This fitting routine takes y = m*f(t - t0) +b, where f(t) is parameterized
  // as an Nth Order Polynomial.

  // X = Drift Times
  // Y = Wire Positions

  //  cout << "beginning Fit" << endl;


  fFitOK = false;
  const Int_t itMax = 10;  //total number of iterations
  if( fSize < 3 )
    return;  // Too few hits to get meaningful results
             // Do keep current values of slope and intercept

  Double_t m;  //, sigmaM;  // Slope, St. Dev. in slope
  Double_t b;  //, sigmaB;  // Intercept, St. Dev in Intercept
  Double_t t0; //, sigmaT0;  // Time offset, St Dev
  // Double_t sigmaY;     // St Dev in delta Y values
  Double_t PosNeg; // +1 or -1 depending on timing and pivot wire.
  Double_t drftVel;
  Double_t err_smallest;
  Int_t it_smallest;

  // Double_t a23 = 0.0, a22 = 1.06E-4, a21 = 1.3E-3, a20 = -4.2E-4, a10 = 2.12E-3;  // We need these if the more complicated fit is attempted.

  Bool_t iter;  //Continue iteration?
  Int_t it; //Iteration counter

  Double_t* xArr = new Double_t[fSize];
  Double_t* xDist = new Double_t[fSize];
  Double_t* xDistTDCcor = new Double_t[fSize];
  Double_t* yArr = new Double_t[fSize];
  Double_t* polArr = new Double_t[fSize];
  Double_t* dydm = new Double_t[fSize];
  Double_t* dydb = new Double_t[fSize];
  Double_t* dydt0 = new Double_t[fSize];


  Double_t bestFit = kBig;

  // Find the index of the pivot wire and copy distances into local arrays
  // Note that as the index of the hits is increasing, the position of the
  // wires is decreasing

  Int_t pivotNum = 0;

  Double_t slope_guess = fSlope;

  drftVel = fPlane->GetDriftVel();
  for (int i = 0; i < fSize; i++) {
    if (fHits[i] == fPivot) {
      pivotNum = i;
    }
    xArr[i] = fHits[i]->GetTime();
    yArr[i] = fHits[i]->GetPos();
  }

  Double_t pvttime = fHits[pivotNum]->GetTime();

  Double_t mi;   //   
  Double_t bi;   //   Initial guesses for m,b and t0.
  Double_t t0i;  //

  TMatrixD J(fSize,3); //Jacobian
  TVectorD D(3); //  Delta vector: Iterative change to fit parameters;
  TVectorD r(fSize); // Residuals vector

  TMatrixD JT(3,fSize); // Transpose(Jacobian)
  TMatrixD JTJ(3,3); // Transpose(Jacobian)*Jacobian
  TVectorD JTr(3); // Transpose(J)*r

  Double_t err,err_old;
  Double_t err_tot[4];
  Double_t m_tot[4];
  Double_t b_tot[4];
  Double_t t0_tot[4];
  Double_t err_it[itMax+1], m_it[itMax+1], b_it[itMax+1], t0_it[itMax+1];

  const Int_t nSignCombos = 4; //Number of different sign combinations
  for (int i = 0; i < nSignCombos; i++) {
      iter = 1;


      mi = slope_guess;
      bi = -1.0;
      t0i = -1.0E-9;

      it = 0;
      while(iter){
	it++;

	for (int j = 0; j < fSize; j++) {

	  if(j == 0 && it == 1){
	    m = mi;
	    b = bi;
	    t0 = t0i;
	    err = 0.0;
	  }
	  if(j <= pivotNum - 2 + i){
	    PosNeg = 1.0;
	  } else {
	    PosNeg = -1.0;
	  }


	  
	  /* // attempt to fit both the time to distance conversion (slope dependent) and the t0 and intercept all at once.

	  xDist[j] = drftVel*(xArr[j] - t0);
	  xDistTDCcor[j] = xDist[j]*(a23*pow(m, -3) + a22*pow(m,-2) + a21/m + a20)/a10; // m*(vel*(time - t0))*(a23m^-3 + a22m^-2 + a21m^-1 + a20)/a10
	  dydb[j] = 1.0;
	  if(xDist[j] < a10){
	    polArr[j] = m*PosNeg*(xDist[j] + xDistTDCcor[j] + fTimeCorrection) + b;
	    dydm[j] = PosNeg*(drftVel*(xArr[j] - t0)*(1 - 2*a23*pow(m,-3) - a22*pow(m,-2) + a20)/a10 + fTimeCorrection);
	    dydt0[j] = -PosNeg*m*drftVel*(1 + (a23*pow(m, -3) + a22*pow(m,-2) + a21/m + a20)/a10);
	  } else {
	    polArr[j] = m*PosNeg*(xDist[j] + xDistTDCcor[j]*a10/xDist[j] + fTimeCorrection) + b;
	    dydm[j] = PosNeg*(xDist[j] + (-2*a23*pow(m,-3) - a22*pow(m,-2) + a20) + fTimeCorrection);
	    dydt0[j] = -m*PosNeg*drftVel;
	  }

	  */

	  // Fit using the predefined time to distance conversion

	  
	  xArr[j] = PosNeg*(fHits[j]->GetDist() + fTimeCorrection - t0*drftVel);

	  polArr[j] = m*(xArr[j]) +b;
	  dydm[j] = xArr[j];
	  dydb[j] = 1;
	  dydt0[j] = -m*drftVel*PosNeg;
	  
	  

	  r(j) = yArr[j] - polArr[j];
      
	  J(j,0) = dydm[j];
	  J(j,1) = dydb[j];
	  J(j,2) = dydt0[j];

	}

	if(it == 1){
	  err_old = kBig;
	}else{
	  err_old = err;
	}

	err = 0;
	for(Int_t jj =0; jj < fSize; jj++){
	  err += pow(r(jj),2);
	}
	m_it[it] = m;
	b_it[it] = b;
	t0_it[it] = t0;
	err_it[it] = err;


	if(TMath::Abs((err_old - err)/err) < 0.0001){

	  

	  err_tot[i] = err_it[it];
	  m_tot[i] = m_it[it];
	  b_tot[i] = b_it[it];
	  t0_tot[i] = t0_it[it];
	  iter = 0;
	  it = 0;
	} else if(it > itMax){	 
	  err_smallest = kBig;
	  bool found = false;
	  for(Int_t jj =1; jj < it; jj++){
	    if(err_it[jj] < err_smallest){
	      it_smallest = jj;
	      found = true;
	    }
	  }

	  if( found ) {
	    err_tot[i] = err_it[it_smallest];
	    m_tot[i] = m_it[it_smallest];
	    b_tot[i] = b_it[it_smallest];
	    t0_tot[i] = t0_it[it_smallest];
	  } else {
	    // happens if all err_it are nan or inf
	    err_tot[i] = kBig;
	    m_tot[i] = kBig;
	    b_tot[i] = kBig;
	    t0_tot[i] = kBig;
	    // probably should set fFitOK = false and bail
	  }

	  iter = 0;
	  it = 0;

	} else {

	  iter = 1;
	  Bool_t DecompOK;
	  JT.Transpose(J);
	  JTJ = JT*J;
	  JTr = JT*r;
	  TDecompSVD lu(JTJ);
	  //  TDecompQRH lu(JTJ, 1.E-40);  // Decompose for linear solution.
	                               // Using the QRH decomposition instead of the SVD decomposition
                                       // because it is about ~2.5x faster; however the tolorance must
                                       // be set very low: ~ 1E-40.  EDIT: with the tolerance set low
	                               // the speed is about the same.


	  D = lu.Solve(JTr,DecompOK);  // set (trans(J)*J)*D = trans(J)*r and solve for D.
	  m += D(0);
	  b += D(1);
	  t0 += D(2);
	}
	
	

      }
      if( err_tot[i] < bestFit || i ==0  ){
	  fLocalSlope = m_tot[i];
	  fInt = b_tot[i];
	
	// 9/15 SPR - This is a dirty hack which
	// is better than misfitting
	if( t0_tot[i] < pvttime ){
	  fT0 = t0_tot[i];
	} else {
	  fT0 = pvttime;
	}

	bestFit = err_tot[i];
      }
  }

    // Pick the best value

  // calculate the best possible chi2 for the track given this slope and intercept
  Double_t chi2 = bestFit;
  Int_t nhits = fSize;
  
  //  CalcChisquare(chi2,nhits);
  fChi2 = chi2;
  fNDoF = nhits-3;
  
  fFitOK = true;

  delete[] xArr;
  delete[] yArr;
  delete[] xDist;
  delete[] xDistTDCcor;
  delete[] polArr;
  delete[] dydm;
  delete[] dydb;
  delete[] dydt0;
}

//_____________________________________________________________________________
Int_t THaVDCCluster::GetPivotWireNum() const
{
  // Get wire number of cluster pivot (hit with smallest drift distance)

  return fPivot ? fPivot->GetWireNum() : -1;
}


//_____________________________________________________________________________
void THaVDCCluster::SetTrack( THaTrack* track )
{
  // Mark this cluster as used by the given track whose number (index+1) is num

  Int_t num = track ? track->GetTrkNum() : 0;

  // Mark all hits
  // FIXME: naahh - only the hits used in the fit! (ignore for now)
  for( int i=0; i<fSize; i++ ) {
    // Bugcheck: hits must either be unused or been used by this cluster's 
    // track (so SetTrack(0) can release a cluster from a track)
    assert( fHits[i] );
    assert( fHits[i]->GetTrkNum() == 0 || fHits[i]->GetTrkNum() == fTrkNum );

    fHits[i]->SetTrkNum( num );
  }
  fTrack = track;
  fTrkNum = num;
}

//_____________________________________________________________________________
chi2_t THaVDCCluster::CalcChisquare( const Double_t* xArr, 
				     const Double_t* dArr,
				     const Int_t* sArr,
				     const Double_t* wArr,
				     Double_t slope, Double_t icpt,
				     Double_t d0 ) const
{
  Int_t npt = 0;
  Double_t chi2 = 0;
  for( int j = 0; j < fSize; ++j ) {
    Double_t x  = xArr[j];
    Double_t y  = sArr[j] * dArr[j];
    Double_t w  = wArr[j];
    Double_t yp = x*slope + icpt + d0*sArr[j];
    if( w < 0 ) continue;
    Double_t d  = y-yp;
    chi2       += d*d*w;
    ++npt;
  }
  return make_pair( chi2, npt );
}


//_____________________________________________________________________________
void THaVDCCluster::CalcChisquare(Double_t& chi2, Int_t& nhits ) const
{
  // given the parameters of the track (slope and intercept), calculate
  // chi2 for the cluster

  Int_t pivotNum = 0;
  for (int j = 0; j < fSize; j++) {
    if (fHits[j] == fPivot) {
      pivotNum = j;
    }
  }
  
  for (int j = 0; j < fSize; j++) {
    Double_t x = fHits[j]->GetDist() + fTimeCorrection;
    if (j>pivotNum) x = -x;
    
    Double_t y = fHits[j]->GetPos();
    Double_t dx = fHits[j]->GetdDist();
    Double_t Y = fSlope * x + fInt;
    Double_t dY = fSlope * dx;
    if (dx <= 0) continue;
    
    if ( fHits[j] == fPivot ) {
      // test the other side of the pivot wire, take the 'best' choice
      Double_t ox = -x;
      Double_t oY =  fSlope * ox + fInt;
      if ( TMath::Abs(y-Y) > TMath::Abs(y-oY) ) {
	x = ox;
	Y = oY;
      }
    }
    chi2 += (Y - y)/dY * (Y - y)/dY;
    nhits++;
  } 
}


//_____________________________________________________________________________
void THaVDCCluster::Print( Option_t* ) const
{
  // Print contents of cluster

  if( fPlane )
    cout << "Plane: " << fPlane->GetPrefix() << endl;
  cout << "Size: " << fSize << endl;

  cout << "Wire numbers:";
  for( int i = 0; i < fSize; i++ ) {
    cout << " " << fHits[i]->GetWireNum();
    if( fHits[i] == fPivot )
      cout << "*";
  }
  cout << endl;
  cout << "Wire raw times:";
  for( int i = 0; i < fSize; i++ ) {
    cout << " " << fHits[i]->GetRawTime();
    if( fHits[i] == fPivot )
      cout << "*";
  }
  cout << endl;
  cout << "Wire times:";
  for( int i = 0; i < fSize; i++ ) {
    cout << " " << fHits[i]->GetTime();
    if( fHits[i] == fPivot )
      cout << "*";
  }
  cout << endl;
  cout << "Wire positions:";
  for( int i = 0; i < fSize; i++ ) {
    cout << " " << fHits[i]->GetPos();
    if( fHits[i] == fPivot )
      cout << "*";
  }
  cout << endl;
  cout << "Wire drifts:";
  for( int i = 0; i < fSize; i++ ) {
    cout << " " << fHits[i]->GetDist();
    if( fHits[i] == fPivot )
      cout << "*";
  }
  cout << endl;

  cout << "intercept(err), local slope(err), global slope, t0(err): " 
       << fInt   << " (" << fSigmaInt   << "), "
       << fLocalSlope << " (" << fSigmaSlope << "), "
       << fSlope << ", "
       << fT0    << " (" << fSigmaT0 << "), fit ok: " << fFitOK
       << endl;

}

///////////////////////////////////////////////////////////////////////////////
ClassImp(THaVDCCluster)
